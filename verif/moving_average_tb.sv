`timescale 1ns/1ps

// Testbench for moving average module
// This uses randomly generated inputs/calculated outputs, and does not require any stimulus files generated by Matlab.
module moving_average_tb #(
    parameter DATA_IN_BITS = 24,
    parameter DATA_OUT_BITS = 24,
    parameter AVERAGE_NUM = 32,
    parameter AVERAGE_BITS = 5,
    parameter ITERATIONS = 32000
)();

    // DUT inputs/outputs
    logic clk;
    logic rst;
    logic data_in_ready;
    logic [DATA_IN_BITS - 1:0] data_in;
    logic data_out_ready;
    logic [DATA_OUT_BITS - 1:0] data_out;

    // DUT
    moving_average #(
        .DATA_IN_BITS (DATA_IN_BITS),
        .DATA_OUT_BITS (DATA_OUT_BITS),
        .AVERAGE_NUM (AVERAGE_NUM),
        .AVERAGE_BITS (AVERAGE_BITS)
    ) dut (
        .clk (clk),
        .rst (rst),
        .data_in_ready (data_in_ready),
        .data_in (data_in),
        .data_out_ready (data_out_ready),
        .data_out (data_out)
    );

    // Clock generation (estimate 10ns clock)
    always begin
        clk = 1'b0;
        #5;
        clk = 1'b1;
        #5;
    end

    // Stimulus/testing logic
    integer i;
    integer j;
    localparam DATA_IN_MAX = 2 ** DATA_IN_BITS - 1;

    logic [DATA_IN_BITS - 1:0] data_in_q [$];
    logic [DATA_OUT_BITS - 1:0] data_out_q [$];
    logic [DATA_IN_BITS - 1:0] data_in_generated;
    logic [DATA_OUT_BITS - 1:0] data_out_generated = 0;
    logic [DATA_OUT_BITS - 1:0] data_out_expected;
    logic data_out_start = 0;

    logic done;


    // Reset and load stimulus
    initial begin
        rst = 1'b1;
        done = 1'b0;
        data_in_generated = '0;
        data_in_ready = 1'b0;

        for (int i = 0; i < ITERATIONS; i++) begin
            data_in_generated = $urandom_range(DATA_IN_MAX);
//            data_in_generated = i;
            data_in_q.push_back(data_in_generated);
        end
        for (int i = 0; i < ITERATIONS; i++) begin
            data_out_generated = data_out_generated + (data_in_q[i] / AVERAGE_NUM);
            if (i % AVERAGE_NUM == AVERAGE_NUM - 1) begin
                data_out_q.push_back(data_out_generated);
                $display("%t: Data_out: %d", $time, data_out_generated);
                data_out_generated = 0;
            end
        end
        
        @(posedge clk);
        rst = 1'b0;
        $display("%t: Random stimulus generated.", $time);
        $display("%t: Data in loaded: %d samples.", $time, data_in_q.size());
        $display("%t: Data out loaded: %d samples.", $time, data_out_q.size());
        @(posedge clk);
        repeat (50) @(posedge clk);
        // Begin verification
        $display("%t: Beginning verification.", $time);
        @(posedge clk);
        data_in_ready <= 1'b1;

        @(posedge done);
        $display("%t: Test passed", $time);
        $finish;
    end

    always @(posedge clk) begin
        if (~rst) begin
//            data_in_ready <= ~data_in_ready;
            data_in_ready <= 1'b1;
        end
    end

    // Clocked DUT stimulus
    always @(negedge clk) begin
        if (data_in_ready) begin
            if (data_in_q.size > 0) begin
                data_in <= data_in_q.pop_front();
            end else begin
                data_in_ready <= 1'b0;
            end
        end
    end

    // Checker
    always @(posedge clk) begin
        if (data_out_ready) begin
            if (data_out_start) begin
                if (data_out_q.size() > 0) begin
                    data_out_expected = data_out_q.pop_front;
                    if (data_out !== data_out_expected) begin
                        $display("%t: Mismatch in data out[%d]: Expected %d, got %d", $time, i, data_out_expected, data_out);
                         $fatal;
                    end
                end else begin
                    done <= 1'b1;
                end
            end else begin
                data_out_start <= 1'b1;
            end
        end
    end
    
    // 
endmodule